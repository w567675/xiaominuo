---
layout: post
title: 尾调用、尾递归
subtitle: ""
date: 2016-06-18
author: w567675
tags:
    - 随手笔记
---









### 尾调用

尾调用（Tail Call）是函数式编程的一个重要概念。简单来说就是一个函数的执行的最后一步是调用另外一个函数。例如：

```js
function b(x) {
  return a(x); // 这个是尾调用
}
```
上面的函数 `b` 在 执行的最后一步调用了函数 `a` ，这是尾调用。

出现下面几种情况都不算尾调用：

1：在调用函数 `a` 之后还有赋值操作。

```js
function b(x) {
  var result =  a(x); // 这里进行了赋值操作
  return result;
}
```

2：这个和第1种情况一样，在调用函数 `a` 之后还有赋值操作。

```js
function b(x) {
  return a(x) + 1; // 这里进行了赋值操作
  return result;
}
```

3：没有return 调用的函数 `a`，函数 `b` 会默认**return undefined 操作**。这样调用的函数 `a` 就不是最后一步操作。

```js
function b(x) {
  a(x); //没有return返回

  /* return undefined */ 
  //  ^--------- 没有返回值得情况下，函数的最后一步操作，返回undefined
}
```

总而言之，**尾调用就是只要是最后一步操作即可，并不一定是在函数尾部**。

```js
function b(x) {
  if(x) {
    return a(x); //尾调用
  }
  return c(x); //尾调用
}
```



### 尾调用优化

函数的调用会在内存中形成 “调用记录” ，叫做 **“调用帧”(call frame)**，用来保存位置和内部变量等信息。

假如一个``函数A``被调用了， 就会形成``调用帧A``。 在``函数A``内部调用了``函数B``，那就会在``调用帧A``顶部插入一个``调用帧B``，等``函数B``执行完毕并将结果返回到``函数A``的时候，``调用帧B``就会销毁。当``函数A``自身运行结束的时候，``调用帧A``也销毁了。

当然如果``函数B``有调用了``函数C``，``函数C``又调用了``函数D``.....以此类推，就会形成一个**调用栈（call stack）**。

尾调用相对来说比较特殊。**因为尾调用是函数的最后一步操作， 就不用在保留外层函数的调用帧（因为已经不需要该调用帧保存的数据）。直接用内部调用帧取代外部的调用帧即可**。

例如：

```js
function b() {
  let x = 1;
  let y = 2;
  return a(y - x);
}
b();

//等同于

function b() {
  return a(1);
}
b();


//等同于

a(1);
```

上面的代码为什么说是可以等同呢？ 如果说函数a 不是尾调用， 那么势必``函数b``要保存内部变量 ``x`` 、``y`` 、 ``函数a``的调用位置等相关数据。但是``函数a``调用之后，``函数b``就执行完毕了。所以**执行到最后一步，可以删除调用帧b，保留调用帧a**。

这就是**“尾调用优化”（Tail Call Optimization）**， 在保留内部函数的调用帧。如果所有函数**都是尾函数调用**，那么**每次执行时调用帧基本只有一项，大大节省了内存**。“尾优化”的意义的存在就是这个。


注意点：

不是所有都能进行“尾调用优化”，例如：

```js
function b(x) {
  let y = 1;

  function a(z) {
    return y - z;
//         ^------ 调用了外部的变量 y    
  }
  return a(x);
}
```

上面的``函数a`` 用到了 ``函数b`` 定义的变量 ``y``。


### 尾递归

### to be continue...